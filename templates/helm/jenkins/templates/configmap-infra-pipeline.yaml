---
apiVersion: v1
kind: ConfigMap
metadata:
  labels:
    app: {{ include "jenkins.fullname" . }}
  name: {{ include "jenkins.fullname" . }}-infra-pipeline-job
data:
  config.xml: |-
    <?xml version='1.1' encoding='UTF-8'?>
    <flow-definition plugin="workflow-job@2.29">
      <actions>
        <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobAction plugin="pipeline-model-definition@1.3.4.1"/>
        <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction plugin="pipeline-model-definition@1.3.4.1">
          <jobProperties/>
          <triggers/>
          <parameters/>
          <options/>
        </org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction>
      </actions>
      <description></description>
      <keepDependencies>false</keepDependencies>
      <properties>
        <io.fabric8.jenkins.openshiftsync.BuildConfigProjectProperty plugin="openshift-sync@1.0.27">
          <uid></uid>
          <namespace></namespace>
          <name></name>
          <resourceVersion></resourceVersion>
        </io.fabric8.jenkins.openshiftsync.BuildConfigProjectProperty>
        <org.jenkinsci.plugins.workflow.job.properties.DisableConcurrentBuildsJobProperty/>
        <org.jenkinsci.plugins.workflow.job.properties.DisableResumeJobProperty/>
      </properties>
      <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps@2.61.1">
        <script>
    def source_git_repo      = &apos;{{ .Values.infra.gitUrl }}&apos;
    def dns_domain           = &apos;{{ .Values.dnsDomain }}&apos;

    def jenkins_name         = &apos;{{ include "jenkins.fullname" . }}&apos;
    def app_dev_name         = &apos;{{ .Values.application.dev.resourceName }}&apos;
    def app_prod_name        = &apos;{{ .Values.application.prod.resourceName }}&apos;
    
    def jenkins_namespace    = &quot;{{ .Release.Namespace }}&quot;
    def infra_namespace      = &quot;{{ .Values.infra.namespace }}&quot;
    def app_dev_namespace    = &quot;{{ .Values.application.dev.namespace }}&quot;
    def app_prod_namespace   = &quot;{{ .Values.application.prod.namespace }}&quot;

    def app_pipeline_job     = &quot;{{ .Values.application.jobName }}&quot;
    
    def nexus_admin_password = &apos;admin123&apos;
    
    def registry_hostname    = &apos;{{ .Values.containerRegistry.hostname }}&apos;
    def registry_username    = &apos;{{ .Values.containerRegistry.username }}&apos;
    def registry_password    = &apos;{{ .Values.containerRegistry.password }}&apos;
    def registry_secret_name = &apos;{{ .Values.containerRegistry.secretName }}&apos;
    def agent_image          = &quot;${registry_hostname}/${jenkins_namespace}/jenkins-agent&quot;

    pipeline {
      agent {
        kubernetes {
          label &apos;jenkins-agent&apos;
          cloud &apos;openshift&apos;
          yaml &quot;&quot;&quot;
    apiVersion: v1
    kind: Pod
    metadata:
      labels:
        pod: jenkins-agent
    spec:
      imagePullSecrets:
      - name: ${registry_secret_name}
      containers:
      - name: agent
        image: ${agent_image}
        command:
        - cat
        tty: true
        securityContext:
          runAsUser: 1001
          allowPrivilegeEscalation: false
      - name: jnlp
        env:
        - name: JENKINS_URL
          value: &apos;http://${jenkins_name}.${jenkins_namespace}.svc.cluster.local:8080/&apos;
        - name: JENKINS_TUNNEL
          value: &apos;${jenkins_name}-jnlp.${jenkins_namespace}.svc.cluster.local:50000&apos;
        securityContext:
          runAsUser: 1001
          allowPrivilegeEscalation: false
      - name: kaniko
        image: gcr.io/kaniko-project/executor:debug
        imagePullPolicy: Always
        command:
        - /busybox/cat
        tty: true
        volumeMounts:
          - name: jenkins-docker-cfg
            mountPath: /kaniko/.docker
      volumes:
      - name: jenkins-docker-cfg
        projected:
          sources:
          - secret:
              name: ${registry_secret_name}
              items:
                - key: .dockerconfigjson
                  path: config.json
    &quot;&quot;&quot;
        }
      }    
        
      stages {
          
        stage(&apos;Cleanup&apos;) {
          steps {
            container(&apos;agent&apos;) {
              delete_namespace(infra_namespace)
              delete_namespace(app_dev_namespace)
              delete_namespace(app_prod_namespace)
        
              sh &quot;&quot;&quot;
                for CHART_NAME in \$(helm ls -q --namespace ${infra_namespace}) &apos;application-dev&apos; &apos;application-prod&apos;
                do
                  helm delete --purge \$CHART_NAME &amp;&gt;/dev/null || echo
                done
              &quot;&quot;&quot;
            }
          }
        }
    
        stage(&apos;Checkout Source&apos;) {
          steps {
            container(&apos;agent&apos;) {
              git url: source_git_repo, branch: &apos;development&apos;
            }
          }
        }
        
        stage(&apos;Create Infra namespace&apos;) {
          steps {
            container(&apos;agent&apos;) {
              sh &quot;kubectl create ns ${infra_namespace}&quot;
            }
          }
        }
        
        stage(&apos;Create Nexus&apos;) {
          steps {
            container(&apos;agent&apos;) {
              sh &quot;&quot;&quot;
                cd templates/helm
                helm install \
                  --namespace ${infra_namespace} \
                  --name nexus \
                  --set fqdn=&apos;nexus.${dns_domain}&apos; \
                  nexus
              &quot;&quot;&quot;
              
              wait_for_deployment_ready(infra_namespace, &apos;nexus&apos;)
            }
          }
        }
    
      
        stage(&apos;Create Sonarqube&apos;) {
          steps {
            container(&apos;agent&apos;) {
    
              sh &quot;&quot;&quot;
                cd templates/helm
                helm install \
                  --namespace ${infra_namespace} \
                  --name postgresql-sonarqube \
                  --set name=postgresql-sonarqube \
                  --set database.name=&apos;sonar&apos; \
                  --set auth.user=&apos;sonar&apos; \
                  --set auth.password=&apos;sonar&apos; \
                  postgresql
              &quot;&quot;&quot;
        
              // Wait for deployment of sonarqube until postgres is ready to handle requests.
              wait_for_deployment_ready(infra_namespace, &apos;postgresql-sonarqube&apos;)
        
              sh &quot;&quot;&quot;
                cd templates/helm
                helm install \
                  --namespace ${infra_namespace} \
                  --name sonarqube \
                  --set fqdn=&apos;sonarqube.${dns_domain}&apos; \
                  --set database.name=&apos;sonar&apos; \
                  --set database.user=&apos;sonar&apos; \
                  --set database.password=&apos;sonar&apos; \
                  --set database.port=5432 \
                  --set database.serviceName=&apos;postgresql-sonarqube&apos; \
                  --set database.namespace=&apos;${infra_namespace}&apos; \
                  sonarqube
              &quot;&quot;&quot;
        
              wait_for_deployment_ready(infra_namespace, &apos;sonarqube&apos;)
        
            }
          }
        }
      
        stage(&apos;Create DEV namespace&apos;) {
          steps {
            container(&apos;agent&apos;) {
              sh &quot;&quot;&quot;
                cd templates/helm
                helm install \
                  --namespace ${app_dev_namespace}\
                  --name application-dev \
                  --set name=&apos;${app_dev_name}&apos; \
                  --set fqdn=&apos;application-dev.${dns_domain}&apos; \
                  --set jenkins.namespace=&apos;${jenkins_namespace}&apos; \
                  --set jenkins.serviceAccount=&apos;default&apos; \
                  --set service.name=&apos;tasks&apos; \
                  --set service.port=8080 \
                  --set ingress.tls.secretName=&apos;application-dev-tls-secret&apos; \
                  --set imageCredentials.registry=&apos;${registry_hostname}&apos; \
                  --set imageCredentials.username=&apos;${registry_username}&apos; \
                  --set imageCredentials.password=&apos;${registry_password}&apos; \
                  application-namespace
              &quot;&quot;&quot;
            }
          }
        }
    
        stage(&apos;Create PROD namespace&apos;) {
          steps {
            container(&apos;agent&apos;) {
    
              sh &quot;&quot;&quot;
                cd templates/helm
                helm install \
                  --namespace ${app_prod_namespace}\
                  --name application-prod \
                  --set name=&apos;${app_prod_name}&apos; \
                  --set fqdn=&apos;application-prod.${dns_domain}&apos; \
                  --set jenkins.namespace=&apos;${jenkins_namespace}&apos; \
                  --set jenkins.serviceAccount=&apos;default&apos; \
                  --set service.name=&apos;green-tasks&apos; \
                  --set service.port=8080 \
                  --set ingress.tls.secretName=&apos;application-prod-tls-secret&apos; \
                  --set imageCredentials.registry=&apos;${registry_hostname}&apos; \
                  --set imageCredentials.username=&apos;${registry_username}&apos; \
                  --set imageCredentials.password=&apos;${registry_password}&apos; \
                  application-namespace
              &quot;&quot;&quot;
            }
          }
        }
      
        stage(&apos;Start Application Pipeline&apos;) {
          steps {
            container(&apos;agent&apos;) {
              build job: &quot;${app_pipeline_job}&quot;,
                wait: false
            }
          }
        }
      }
    }
    
    def delete_namespace(namespace_name) {
      sh &quot;&quot;&quot;
        kubectl delete namespace $namespace_name --ignore-not-found=true
        for i in \$(seq 1 30);
        do
          kubectl get namespaces $namespace_name &amp;&gt;/dev/null || break
          sleep 2
        done
      &quot;&quot;&quot;
    }
    
    def get_pod_name(namespace, app_name) {
      return sh (
        script: &quot;kubectl --namespace $namespace get pod | grep &apos;^$app_name&apos; | awk &apos;{ print \$1 }&apos;&quot;,
        returnStdout: true
      ).trim()
    }
    
    def wait_for_deployment_ready(namespace, deployment) {
      sh &quot;&quot;&quot;
        while true;
        do
          READY=\$(kubectl --namespace $namespace get deployment $deployment -o=custom-columns=AVAILABLE:.status.availableReplicas --no-headers)
          if [ \$READY -ge 1 ] 2&gt;/dev/null
          then
            break
          fi
          
          sleep 10
        done
      &quot;&quot;&quot;
    }</script>
        <sandbox>true</sandbox>
      </definition>
      <triggers/>
      <disabled>false</disabled>
    </flow-definition>
